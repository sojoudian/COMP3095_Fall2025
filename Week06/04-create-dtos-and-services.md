# Create DTOs, Services, Repository, and Controller

## Overview

In this section, you will implement the complete layered architecture for the order-service:
1. **DTOs** - Data Transfer Objects for API requests/responses
2. **Repository** - Data access layer
3. **Service** - Business logic layer with transaction management
4. **Controller** - REST API layer

---

## Understanding the Layered Architecture

### Architecture Flow

```
┌──────────────────────┐
│   REST API Client    │ (Postman, Browser, etc.)
└──────────────────────┘
          ↓ HTTP Request (JSON)
┌──────────────────────┐
│     Controller       │ ← @RestController
│  (OrderController)   │   Handles HTTP, validates input
└──────────────────────┘
          ↓ OrderRequest (DTO)
┌──────────────────────┐
│      Service         │ ← @Service, @Transactional
│   (OrderService)     │   Business logic, transactions
└──────────────────────┘
          ↓ Order (Entity)
┌──────────────────────┐
│     Repository       │ ← Extends JpaRepository
│ (OrderRepository)    │   Data access, CRUD operations
└──────────────────────┘
          ↓ SQL Queries
┌──────────────────────┐
│  PostgreSQL Database │
└──────────────────────┘
```

### Why This Architecture?

**Separation of Concerns:**
- Each layer has specific responsibility
- Changes in one layer don't affect others
- Easier to test and maintain

**Benefits:**
- **Controller:** Handles HTTP without business logic
- **Service:** Business logic without HTTP details
- **Repository:** Data access without business logic
- **DTOs:** API contract independent of internal model

---

## Step 1: Create OrderLineItemDto

### 1.1 Create OrderLineItemDto Class

**Location:** `order-service/src/main/java/ca/gbc/comp3095/orderservice/dto/OrderLineItemDto.java`

**Steps:**
1. Right-click on `dto` package
2. Select **New → Java Class**
3. Name: `OrderLineItemDto`
4. Click **OK**

### 1.2 Implement OrderLineItemDto

**Complete OrderLineItemDto.java:**

```java
package ca.gbc.comp3095.orderservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class OrderLineItemDto {
    private Long id;
    private String skuCode;
    private BigDecimal price;
    private Integer quantity;
}
```

### 1.3 Understanding the Code

**Why DTO?**
- Separates external API from internal entities
- Can add validation annotations (`@NotNull`, `@Min`)
- Can exclude sensitive fields (like internal IDs)
- Allows API evolution without changing entities

**Lombok Annotations:**
- `@Data` - Generates getters, setters, toString, equals, hashCode
- `@AllArgsConstructor` - Constructor with all fields
- `@NoArgsConstructor` - No-argument constructor (required for JSON deserialization)

**Fields:**
- `id` - Optional, not used in POST requests but available for future use
- `skuCode` - Product identifier (e.g., "sku_12334A")
- `price` - Item price as BigDecimal for precision
- `quantity` - Number of items

**JSON Example:**
```json
{
  "id": null,
  "skuCode": "sku_12334A",
  "price": 99.99,
  "quantity": 5
}
```

---

## Step 2: Create OrderRequest

### 2.1 Create OrderRequest Class

**Location:** `order-service/src/main/java/ca/gbc/comp3095/orderservice/dto/OrderRequest.java`

**Steps:**
1. Right-click on `dto` package
2. Select **New → Java Class**
3. Name: `OrderRequest`
4. Click **OK**

### 2.2 Implement OrderRequest

**Complete OrderRequest.java:**

```java
package ca.gbc.comp3095.orderservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class OrderRequest {
    private List<OrderLineItemDto> orderLineItemDtoList;
}
```

### 2.3 Understanding the Code

**Purpose:**
- Represents the request body for POST /api/order
- Contains list of order line items
- No order number in request (generated by service)

**JSON Example:**
```json
{
  "orderLineItemDtoList": [
    {
      "skuCode": "sku_12334A",
      "price": 888.00,
      "quantity": 5
    },
    {
      "skuCode": "sku_799533",
      "price": 288.00,
      "quantity": 3
    }
  ]
}
```

---

## Step 3: Create OrderRepository

### 3.1 Create OrderRepository Interface

**Location:** `order-service/src/main/java/ca/gbc/comp3095/orderservice/repository/OrderRepository.java`

**Steps:**
1. Right-click on `repository` package
2. Select **New → Java Class**
3. In the dialog, change **Kind** from "Class" to **Interface**
4. Name: `OrderRepository`
5. Click **OK**

### 3.2 Implement OrderRepository

**Complete OrderRepository.java:**

```java
package ca.gbc.comp3095.orderservice.repository;

import ca.gbc.comp3095.orderservice.model.Order;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    // No methods needed - JpaRepository provides all CRUD operations
}
```

### 3.3 Understanding the Code

**What is JpaRepository?**
- Spring Data JPA interface
- Provides built-in CRUD operations
- No implementation needed (Spring generates it)

**Generic Parameters:**
```java
JpaRepository<Order, Long>
            │     │
            │     └─ Primary key type (Long)
            └─ Entity type (Order)
```

**Built-in Methods (No Code Needed):**
- `save(Order order)` - Save or update order
- `findById(Long id)` - Find order by ID
- `findAll()` - Get all orders
- `deleteById(Long id)` - Delete order by ID
- `count()` - Count total orders
- `existsById(Long id)` - Check if order exists

**Custom Queries (Optional):**
```java
// If needed, you can add custom methods:
List<Order> findByOrderNumber(String orderNumber);
List<Order> findByOrderNumberContaining(String keyword);
// Spring Data JPA derives query from method name
```

**@Repository Annotation:**
- Marks interface as repository component
- Enables exception translation
- Component scan detection

---

## Step 4: Create OrderService

### 4.1 Create OrderService Class

**Location:** `order-service/src/main/java/ca/gbc/comp3095/orderservice/service/OrderService.java`

**Steps:**
1. Right-click on `service` package
2. Select **New → Java Class**
3. Name: `OrderService`
4. Click **OK**

### 4.2 Implement OrderService

**Complete OrderService.java:**

```java
package ca.gbc.comp3095.orderservice.service;

import ca.gbc.comp3095.orderservice.dto.OrderLineItemDto;
import ca.gbc.comp3095.orderservice.dto.OrderRequest;
import ca.gbc.comp3095.orderservice.model.Order;
import ca.gbc.comp3095.orderservice.model.OrderLineItem;
import ca.gbc.comp3095.orderservice.repository.OrderRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class OrderService {

    private final OrderRepository orderRepository;

    public void placeOrder(OrderRequest orderRequest) {
        // Generate unique order number
        String orderNumber = UUID.randomUUID().toString();

        // Convert DTOs to Entities
        List<OrderLineItem> orderLineItems = orderRequest.getOrderLineItemDtoList()
                .stream()
                .map(this::mapToOrderLineItem)
                .toList();

        // Create Order entity
        Order order = Order.builder()
                .orderNumber(orderNumber)
                .orderLineItems(orderLineItems)
                .build();

        // Save order (cascade will save line items)
        orderRepository.save(order);

        log.info("Order {} placed successfully with {} items",
                orderNumber, orderLineItems.size());
    }

    private OrderLineItem mapToOrderLineItem(OrderLineItemDto dto) {
        return OrderLineItem.builder()
                .skuCode(dto.getSkuCode())
                .price(dto.getPrice())
                .quantity(dto.getQuantity())
                .build();
    }
}
```

### 4.3 Understanding the Code

#### **Class-Level Annotations:**

**@Service:**
```java
@Service
```
- Marks class as service component
- Spring will detect and manage as bean
- Enables dependency injection

**@RequiredArgsConstructor (Lombok):**
```java
@RequiredArgsConstructor
```
- Generates constructor for `final` fields
- Enables constructor-based dependency injection
- Equivalent to:
```java
public OrderService(OrderRepository orderRepository) {
    this.orderRepository = orderRepository;
}
```

**@Slf4j (Lombok):**
```java
@Slf4j
```
- Generates logger field: `private static final Logger log = ...`
- Use with: `log.info()`, `log.error()`, `log.debug()`

**@Transactional:**
```java
@Transactional
```
- All methods execute in database transaction
- Automatic rollback on exception
- ACID guarantees (Atomicity, Consistency, Isolation, Durability)

#### **placeOrder() Method:**

**1. Generate Order Number:**
```java
String orderNumber = UUID.randomUUID().toString();
```
- Generates unique identifier: "550e8400-e29b-41d4-a716-446655440000"
- Ensures each order has unique number
- Production systems might use: "ORD-" + timestamp + counter

**2. Convert DTOs to Entities:**
```java
List<OrderLineItem> orderLineItems = orderRequest.getOrderLineItemDtoList()
        .stream()
        .map(this::mapToOrderLineItem)
        .toList();
```
- Stream over DTO list
- Map each DTO to entity using helper method
- Collect as list

**3. Create Order Entity:**
```java
Order order = Order.builder()
        .orderNumber(orderNumber)
        .orderLineItems(orderLineItems)
        .build();
```
- Use Builder pattern
- Set order number
- Add line items
- No need to set ID (auto-generated)

**4. Save Order:**
```java
orderRepository.save(order);
```
- Saves order to database
- **Cascade saves line items** (because of `CascadeType.ALL`)
- Returns saved order with generated ID

**5. Log Success:**
```java
log.info("Order {} placed successfully with {} items",
        orderNumber, orderLineItems.size());
```
- Logs order placement
- Helpful for debugging and monitoring
- Production: Use structured logging (JSON)

#### **mapToOrderLineItem() Helper Method:**

```java
private OrderLineItem mapToOrderLineItem(OrderLineItemDto dto) {
    return OrderLineItem.builder()
            .skuCode(dto.getSkuCode())
            .price(dto.getPrice())
            .quantity(dto.getQuantity())
            .build();
}
```
- Converts DTO to Entity
- Maps fields one-by-one
- No ID set (auto-generated on save)
- Could use MapStruct library for complex mappings

### 4.4 Transaction Management

**What Happens:**
```java
@Transactional
public void placeOrder(OrderRequest orderRequest) {
    // BEGIN TRANSACTION

    Order order = Order.builder()...build();
    orderRepository.save(order);  // INSERT into orders
                                  // INSERT into order_line_items (cascade)

    // COMMIT TRANSACTION (if no exception)
    // ROLLBACK (if exception thrown)
}
```

**Benefits:**
- ✅ All-or-nothing: Either everything saves or nothing saves
- ✅ Data consistency guaranteed
- ✅ Automatic rollback on errors
- ✅ No orphaned data in database

**Example Rollback:**
```java
@Transactional
public void placeOrder(OrderRequest orderRequest) {
    orderRepository.save(order);  // Saves order

    // If this throws exception:
    throw new RuntimeException("Payment failed");

    // Transaction rolls back
    // Order is NOT saved to database
}
```

---

## Step 5: Create OrderController

### 5.1 Create OrderController Class

**Location:** `order-service/src/main/java/ca/gbc/comp3095/orderservice/controller/OrderController.java`

**Steps:**
1. Right-click on `controller` package
2. Select **New → Java Class**
3. Name: `OrderController`
4. Click **OK**

### 5.2 Implement OrderController

**Complete OrderController.java:**

```java
package ca.gbc.comp3095.orderservice.controller;

import ca.gbc.comp3095.orderservice.dto.OrderRequest;
import ca.gbc.comp3095.orderservice.service.OrderService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/order")
@RequiredArgsConstructor
public class OrderController {

    private final OrderService orderService;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public String placeOrder(@RequestBody OrderRequest orderRequest) {
        orderService.placeOrder(orderRequest);
        return "Order Placed Successfully";
    }
}
```

### 5.3 Understanding the Code

#### **Class-Level Annotations:**

**@RestController:**
```java
@RestController
```
- Combines `@Controller` + `@ResponseBody`
- All methods return data (not views)
- Responses automatically serialized to JSON

**@RequestMapping:**
```java
@RequestMapping("/api/order")
```
- Base path for all endpoints in this controller
- All methods will be under `/api/order`

**@RequiredArgsConstructor:**
- Generates constructor for `final` fields
- Injects OrderService dependency

#### **placeOrder() Method:**

**@PostMapping:**
```java
@PostMapping
```
- Maps HTTP POST requests
- Full path: `POST /api/order`
- Receives JSON in request body

**@ResponseStatus:**
```java
@ResponseStatus(HttpStatus.CREATED)
```
- Sets HTTP status code to 201 Created
- Indicates resource successfully created
- Standard for POST endpoints that create resources

**@RequestBody:**
```java
public String placeOrder(@RequestBody OrderRequest orderRequest)
```
- Deserializes JSON request body to OrderRequest object
- Spring automatically converts JSON to Java object
- Validation can be added with `@Valid`

**Method Body:**
```java
orderService.placeOrder(orderRequest);
return "Order Placed Successfully";
```
- Delegates to service layer
- Returns success message
- Message serialized to JSON response

**Complete Flow:**
```
POST /api/order
Content-Type: application/json
Body: {"orderLineItemDtoList": [...]}

    ↓ @RequestBody deserializes JSON

OrderRequest object

    ↓ Call service

orderService.placeOrder(orderRequest)

    ↓ Service processes

Order saved to database

    ↓ Return response

HTTP 201 Created
Body: "Order Placed Successfully"
```

---

## Step 6: Complete Architecture Verification

### 6.1 Verify All Files Created

**Checklist:**
```
order-service/src/main/java/ca/gbc/comp3095/orderservice/
├── controller/
│   └── ✅ OrderController.java
├── dto/
│   ├── ✅ OrderLineItemDto.java
│   └── ✅ OrderRequest.java
├── model/
│   ├── ✅ Order.java (from Step 3)
│   └── ✅ OrderLineItem.java (from Step 3)
├── repository/
│   └── ✅ OrderRepository.java
├── service/
│   └── ✅ OrderService.java
└── ✅ OrderServiceApplication.java
```

### 6.2 Build Project

**Command:**
```bash
cd order-service
./gradlew clean build -x test
```
- `-x test` skips tests (database not configured yet)

**Expected Output:**
```
BUILD SUCCESSFUL in 8s
```

### 6.3 Verify No Compilation Errors

**Check:**
1. No red underlines in any file
2. All imports resolved
3. Build succeeds

---

## Summary

### What You Created:

**DTOs:**
- ✅ `OrderLineItemDto` - Represents line item in API requests
- ✅ `OrderRequest` - Represents order creation request

**Repository:**
- ✅ `OrderRepository` - Data access layer, extends JpaRepository

**Service:**
- ✅ `OrderService` - Business logic layer
  - Generates order numbers
  - Converts DTOs to entities
  - Saves orders with transaction management
  - Logs operations

**Controller:**
- ✅ `OrderController` - REST API layer
  - POST /api/order endpoint
  - Returns 201 Created status
  - Handles JSON serialization/deserialization

### Architecture Layers:

```
OrderController (REST)
    ↓
OrderService (Business Logic + Transactions)
    ↓
OrderRepository (Data Access)
    ↓
PostgreSQL Database
```

### Key Concepts Covered:

- ✅ DTO pattern for API separation
- ✅ Repository pattern for data access
- ✅ Service layer for business logic
- ✅ Transaction management with @Transactional
- ✅ Dependency injection with constructor injection
- ✅ Cascade operations (save order → saves line items)
- ✅ REST API with Spring MVC annotations
- ✅ Lombok for boilerplate reduction

### Request/Response Flow:

**Example Request:**
```json
POST /api/order
Content-Type: application/json

{
  "orderLineItemDtoList": [
    {
      "skuCode": "sku_12334A",
      "price": 888.00,
      "quantity": 5
    },
    {
      "skuCode": "sku_799533",
      "price": 288.00,
      "quantity": 3
    }
  ]
}
```

**Response:**
```
HTTP/1.1 201 Created
Content-Type: text/plain

Order Placed Successfully
```

**Database Result:**
```sql
-- orders table
INSERT INTO orders (id, order_number) VALUES (1, '550e8400-e29b-41d4-a716-446655440000');

-- order_line_items table
INSERT INTO order_line_items (id, sku_code, price, quantity, order_id)
VALUES (1, 'sku_12334A', 888.00, 5, 1);

INSERT INTO order_line_items (id, sku_code, price, quantity, order_id)
VALUES (2, 'sku_799533', 288.00, 3, 1);
```

---

## Next Steps

You have successfully implemented the complete layered architecture. Next, you will:
1. Configure PostgreSQL database connection
2. Create application.properties
3. Setup PostgreSQL Docker container
4. Test the application locally

Continue to [05-database-configuration.md](05-database-configuration.md)

---

**Files Created in This Section:**
- ✅ `OrderLineItemDto.java` - DTO for line items
- ✅ `OrderRequest.java` - DTO for order requests
- ✅ `OrderRepository.java` - Repository interface
- ✅ `OrderService.java` - Service with business logic
- ✅ `OrderController.java` - REST controller
